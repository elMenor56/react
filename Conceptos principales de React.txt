Conceptos principales de React:

1. Componente: Un componente es una función que devuelve una parte visual de la aplicación y puede reutilizarse para no escribir el mismo código varias veces.
Es una función (o clase, pero hoy casi siempre se usan funciones).
Devuelve código JSX (que parece HTML).
Se puede reutilizar en diferentes lugares.
Puede recibir datos (por medio de props).

2. Props: Los props (abreviatura de properties) son una forma de pasar información de un componente padre a un componente hijo en React.
Piensa en los props como paquetes de datos o mensajes que un componente envía a otro.
Los props son argumentos que recibe un componente.
Permiten personalizar el contenido del componente.
Son solo de lectura (no se pueden cambiar dentro del componente hijo).

3. Estado: En React, el estado (state) es una forma de guardar información que puede cambiar con el tiempo dentro de un componente.
Cuando ese dato cambia, React actualiza automáticamente la interfaz (la parte visual de la página).
El estado es como la memoria del componente.
Guarda datos que pueden cambiar, como:
El número de clics en un botón.
Lo que el usuario escribe en un formulario.
Si un menú está abierto o cerrado.
Datos que vienen de una API, etc.

4. Hooks: En React, los Hooks son funciones especiales que permiten usar características de React —como el estado o el ciclo de vida de los componentes— sin necesidad de escribir clases.
En otras palabras, los Hooks hacen que los componentes de función sean más poderosos y puedan hacer casi todo lo que antes solo hacían los componentes de clase.

5. Event Listener: Un event listener (o escuchador de eventos) es una función que espera a que ocurra un evento en una página web o aplicación, como un clic, un cambio en un campo de texto o el envío de un formulario.
En pocas palabras, detecta acciones del usuario y ejecuta algo cuando pasan.
En React, los event listeners se agregan directamente al JSX con nombres de eventos en camelCase (por ejemplo, onClick, onChange, onSubmit, etc.).

==============================================================

CONCEPTOS PRINCIPALES DE JSX

¿Qué es JSX?
JSX (JavaScript XML) es una extensión de JavaScript que permite escribir HTML dentro de JavaScript.
React usa JSX para describir cómo debe verse la interfaz de usuario (UI).

Solo un elemento raíz:
JSX siempre debe devolver un único elemento padre. Si hay varios, se deben envolver en un <div> o en un fragmento (<>...</>).

Expresiones en llaves {}:
Puedes insertar variables, funciones o operaciones dentro del JSX usando llaves.

Atributos en camelCase:
En lugar de class, se usa className. Otros atributos como onclick se escriben onClick.

Estilos en linea:
Se escriben como un objeto JavaScript con doble llave {{ }}.

No usar etiquetas HTML sin cerrar:
En JSX, todas las etiquetas deben cerrarse, incluso las vacías.

Renderizado condicional:
Se puede mostrar contenido según una condición usando operadores ternarios o &&.

Comentarios:
Los comentarios dentro de JSX se escriben con llaves y /* ... */. {/*...*/}

==============================================================

EXPLICACION DE ARCHIVOS Y FUNCIONAMIENTO DEL CODIGO

main.jsx:
es el archivo de inicio que enlaza React con el HTML del navegador.
Este archivo no debería tener lógica de la aplicación, solo configuración de inicio.

Template literals (`texto ${variable}`):
Permiten insertar variables dentro de cadenas de texto.

Desestructuración de props:
En lugar de props.texto, usamos directamente { texto } en la definición del componente.
Más limpio y directo.

Renderizado condicional (operador ternario):
className={ esBotonDeClick ? 'boton-clic' : 'boton-reiniciar' }
Si esBotonDeClick es true, aplica una clase; si no, aplica otra.
Este patrón es muy común para cambiar estilos o comportamiento según props.

Flujo de datos (unidireccional):
En React, los datos viajan de padres a hijos mediante props.
App guarda el estado y pasa los valores (numClics) a los hijos (Contador, Boton).
Los hijos no cambian el estado directamente, solo llaman a funciones que lo actualizan.
Este patrón se llama "lifting state up" (elevar el estado al padre).

Importación de imágenes:
Importar una imagen como módulo (ej. import Logo from '../public/img/logo.png') es más limpio y seguro que usar rutas relativas.
Vite/React optimizan automáticamente las imágenes importadas.

Render condicional: cambia el contenido o estilos según una condición (? :).

props.children: representa el contenido que está entre las etiquetas del componente. 
Ejemplo: <Boton>1</Boton> → children = "1".

evaluate (mathjs)
Convierte un string matemático (ej. "2+2") en su resultado (4).

Funciones manejadoras (handlers)
manejarClic, manejarClear, etc., se pasan como props para responder a eventos.

Eventos:
onClick={() => props.manejarClic(props.children)} → ejecuta una función cuando se hace clic.

MathJS:
Librería externa para evaluar expresiones matemáticas de tipo texto.
==============================================================

FUNCIONAMIENTO DEL PRIMER PROYECTO: testimonios

1. Testimonio.jsx — el componente hijo
Este archivo define cómo se ve un testimonio (una tarjeta o bloque visual con imagen, texto, nombre, etc.).
Podríamos decir que es una “plantilla” reutilizable.

Qué hace:
Usa las props (propiedades) para recibir datos desde otro componente (por ejemplo, el nombre, país, testimonio e imagen).
Devuelve JSX, que React transforma en HTML real y muestra en pantalla.
export default Testimonio; permite que otros archivos (como App.jsx) lo importen y lo usen.

2. App.jsx — el componente padre
Este archivo es el corazón del renderizado.
Importa el componente Testimonio y crea instancias de él con diferentes datos.

Qué hace:
Importa el componente Testimonio.
Llama al componente varias veces, enviando diferentes props.
React renderiza todo eso y lo muestra en pantalla como HTML.

3. Carpeta public/imagenes
Las imágenes deben estar en public porque:
El navegador solo puede acceder a archivos públicos, no a los que están dentro de src/.
public/ es donde se colocan los recursos estáticos (imágenes, íconos, fuentes, etc.) que se usarán directamente en el navegador.
Cuando React compila el proyecto, lo que está en public/ se copia tal cual al resultado final

4. Flujo completo
App.jsx importa y usa Testimonio.
App.jsx pasa datos como props → (nombre, pais, imagen, etc.)
Testimonio.jsx recibe esas props y construye el JSX.
React renderiza todo en el navegador.
Las imágenes se cargan desde public/imagenes.

5. Jerarquía de componentes
main.jsx → renderiza <App />
App.jsx → contiene varios <Testimonio />
Testimonio.jsx → muestra los datos en pantalla.

En resumen:
Testimonio.jsx define cómo se ve un testimonio.
App.jsx decide qué testimonios mostrar y con qué datos.
public/ almacena los archivos visibles por el navegador (como las imágenes).

==============================================================

FUNCIONAMIENTO DEL SEGUNDO PROYECTO: Contador de clicks

Estructura general:
Tienes tres componentes principales:
App.jsx → El “cerebro” de la app (controla el estado y la lógica).
Boton.jsx → Componente reutilizable que ejecuta una función al hacer clic.
Contador.jsx → Muestra visualmente el número de clics.

1. App.jsx — Componente principal
¿Qué hace useState?:
useState te permite crear y actualizar valores que cambian con el tiempo dentro del componente.
numClics → almacena el número actual de clics.
setNumClics → función que actualiza ese valor.
useState(0) → el valor inicial es 0.

Funciones que cambian el estado:
const manejarClic = () => {
  setNumClics(numClics + 1); // Incrementa el contador
}

const reiniciarContador = () =>{
  setNumClics(0); // Reinicia el contador
}
Cada vez que llamas setNumClics, React vuelve a renderizar el componente mostrando el nuevo valor.

Estructura JSX:
Aquí ocurre lo siguiente:
+----------------------+----------------------------------+------------------------------------------------------------+
| Componente           | Qué hace                         | Qué props recibe                                           |
+----------------------+----------------------------------+------------------------------------------------------------+
| <Contador />         | Muestra el número de clics        | numClics                                                   |
+----------------------+----------------------------------+------------------------------------------------------------+
| <Boton /> (clic)     | Suma +1 al contador               | texto="Clic", esBotonDeClick={true}, manejarClic={manejarClic} |
+----------------------+----------------------------------+------------------------------------------------------------+
| <Boton /> (reiniciar)| Reinicia el contador a 0          | texto="Reiniciar", esBotonDeClick={false}, manejarClic={reiniciarContador} |
+----------------------+----------------------------------+------------------------------------------------------------+

2. Boton.jsx — Componente reutilizable
Explicación:
Props desestructurados: { texto, esBotonDeClick, manejarClic }

className={esBotonDeClick ? 'boton-clic' : 'boton-reiniciar'}:
→ Usa operador ternario para aplicar una clase CSS según el tipo de botón.

onClick={manejarClic}:
→ Asigna la función que debe ejecutarse cuando se hace clic.

{texto}:
→ Muestra el texto dentro del botón (“Clic” o “Reiniciar”).
Este componente es reutilizable, ya que no sabe qué hace la función manejarClic, solo la ejecuta.

3. Contador.jsx — Componente visual simple
Solo recibe una prop: numClics.
La muestra dentro de un <div>.
Cada vez que numClics cambia (desde App.jsx), React vuelve a renderizar este número automáticamente.

4. Flujo completo de funcionamiento

El estado numClics vive en App.jsx.
App.jsx pasa ese valor y funciones como props a los hijos (Contador y Boton).
Cuando haces clic en un botón:
Boton ejecuta manejarClic o reiniciarContador.
Estas funciones modifican el estado con setNumClics.
React detecta el cambio y vuelve a renderizar App, actualizando el valor mostrado en Contador.

==============================================================

FUNCIONAMIENTO DEL TERCER PROYECTO: Calculadora

1. El componente principal (App.jsx) controla todo el comportamiento.
Usa useState para guardar el texto que el usuario escribe en pantalla (input).

2. Cuando el usuario hace clic en un botón numérico u operador (Boton.jsx):
Se ejecuta la función agregarInput(val), que concatena el valor al estado input.
Esto actualiza automáticamente la pantalla (Pantalla.jsx) gracias a la reactividad de React.

3. Cuando el usuario presiona el botón “=” (Boton.jsx):
Se ejecuta calcularResultado(), que usa evaluate() de mathjs para resolver la operación escrita (por ejemplo, "5+3*2" → 11).
El resultado se muestra en la pantalla.

4. Cuando se presiona “Clear” (BotonClear.jsx):
Se llama a setInput(''), que vacía la pantalla.

5. Los componentes se comunican con props:
App → envía funciones (manejarClic, manejarClear) y datos (input) a los componentes hijos.
Los hijos llaman esas funciones cuando ocurre un evento (clic), devolviendo la acción al padre.

==============================================================

FUNCIONAMIENTO DEL CUARTO PROYECTO: Lista de tareas

App.jsx → estructura principal y logo.
ListaDeTareas.jsx → controla el estado global de las tareas.
TareaFormulario.jsx → maneja el formulario de entrada de texto.
Tarea.jsx → muestra cada tarea individual con opciones para marcar o eliminar.
useState controla los cambios dinámicos.
La app funciona gracias a la comunicación de componentes mediante props.
Todo cambio en el estado (agregar, eliminar o completar) hace que React vuelva a renderizar la lista automáticamente.